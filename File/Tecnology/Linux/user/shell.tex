\chapter{The \unix\ Shell}\label{shell-chapter}

\begin{fortune}
\raggedright
Making files is easy under the UNIX operating system.  Therefore,
users tend to create numerous files using large amounts of file
space.  It has been said that the only standard thing about all UNIX
systems is the message-of-the-day telling users to clean up their
files.\\
\raggedleft System V.2 administrator's guide
\end{fortune}

\section{\unix\ Commands}

When you first log into a \unix\ system, you are presented with
something that looks like the following:

\begin{screen}
\begin{verbatim}
/home/larry#
\end{verbatim}
\end{screen}

That ``something'' is called a \concept{prompt}.  As its name would
suggest, it is prompting you to enter a command.  Every \unix\ command
is a sequence of letters, numbers, and characters.\glossary{character}
There are no spaces, however.  Some valid \unix\ commands are {\tt
  mail}, {\tt cat}, and {\tt CMU\_is\_Number-5}.  Some characters
aren't allowed---we'll go into that later.  \unix\ is also
\concept{case-sensitive}.  This means that {\tt cat} and {\tt Cat} are
different commands.\footnote{Case sensitivity is a very personal
  thing.  Some operating systems, such as OS/2\index{OS/2} or Windows
  NT\index{Windows NT} are case preserving, but not case sensitive.
  In practice, \unix\ rarely uses the different cases.  It is unusual
  to have a situation where {\tt cat} and {\tt Cat} are different
  commands.}

The prompt is displayed by a special program called the
\concept{shell}.  Shells accept commands, and run those commands. They
can also be programmed in their own language, and programs written in
that language are called ``shell
scripts''.\index{shell!programming}\index{shell!script}

There are two major types of shells in \unix: Bourne shells and C
shells.  Bourne shells are named after their inventor, Steven
Bourne.\index{Bourne, Steve R.} Steven Bourne wrote the original
\unix\ shell {\tt sh}\ttindex{sh}, and most shells since then end in
the letters {\tt sh} to indicate they are extentions on the original
idea.  There are many implementations of his shell, and all those
specific shell programs are called Bourne shells. Another class of
shells, C shells (originally implemented by Bill Joy\index{Joy,
  Bill}), are also common. Traditionally, Bourne shells have been used
for shell scripts and compatibility with the original {\tt sh} while C
shells have been used for interactive use.  (C shells have had the
advantages of having better interactive features but somewhat harder
programming features.)

\linux\ comes with a Bourne shell called {\tt bash}\ttindex{bash},
written by the Free Software Foundation.\index{Free Software Foundation} 
{\tt bash} stands for {\bf B}ourne {\bf A}gain {\bf Sh}ell, one of the
many bad puns in \unix.  It is an ``advanced'' Bourne shell:  it
contains the standard programming features found in all Bourne shells
with many interactive features commonly found in C shells.  {\tt bash}
is the default shell to use running \linux.

When you first login, the prompt is displayed by {\tt bash}, and you
are running your first \unix\ program, the {\tt bash} shell.  As long
as you are logged in, the {\tt bash} shell will constantly be running.

\subsection{A Typical \unix\ Command}

The first command to know is {\tt cat}\ttindex{cat}.  To use it,
type {\tt cat}, and then \ret:

\begin{screen}\begin{verbatim}
/home/larry# cat

\end{verbatim}\end{screen}

If you now have a cursor on a line by itself, you've done the correct
thing.  There are several variances you could have typed---some would
work, some wouldn't.

\begin{itemize}
\item If you misspelled {\tt cat}, you would have seen
\begin{screen}\begin{verbatim}
/home/larry# ct
ct: command not found
/home/larry#
\end{verbatim}\end{screen}
Thus, the shell informs you that it couldn't find a program named
``{\tt ct}'' and gives you another prompt to work with. Remember,
\unix\ is case sensitive: {\tt CAT} is a misspelling.
\item You could have also placed whitespace before the command, like
  this:\footnote{The `{\tt \char `\ }' indicates that the user typed a
    space.}
\begin{screen}\begin{verbatim*}
/home/larry#     cat     
\end{verbatim*}\end{screen}
This produces the correct result and runs the {\tt cat} program.
% any more ideas for common things?
\item You might also press return on a line by itself. Go right
  ahead---it does absolutely nothing.
\end{itemize}

I assume you are now in {\tt cat}\ttindex{cat}.  Hopefully, you're
wondering what it is doing.  No, it is not a game.  {\tt cat} is a
useful utility that won't seem useful at first.  Type anything and
hit return.  What you should have seen is:

\begin{tscreen}
/home/larry\# cat\\
{\sl Help! I'm stuck in a Linux program!}\\
Help! I'm stuck in a Linux program!
\end{tscreen}

(The {\sl slanted\/} text indicates what I typed to {\tt cat}.) What
{\tt cat} seems to do is echo the text right back at yourself.  This
is useful at times, but isn't right now.  So let's get out of this
program and move onto commands that have more obvious benefits.

To end many \unix\ commands, type \eof\footnote{Hold down the key
  labeled ``Ctrl'' and press ``d'', then let go of both.}. \eof\ is
the end-of-file character, or EOF for short.\index{end-of-text}
\index{end-of-file} Alternatively, it stands for end-of-text,
depending on what book you read.  I'll refer to it as an end-of-file.
It is a control character that tells \unix\ programs that you (or
another program) is done entering data.  When {\tt cat} sees you
aren't typing anything else, it terminates.

For a similar idea, try the program {\tt sort}.\ttindex{sort} As its
name indicates, it is a sorting program.  If you type a couple of
lines, then press \eof, it will output those lines in a sorted order.
These types of programs are called {\bf filters}\glossary{filter},
because they take in text, filter it, and output the text slightly
differently.  Both {\tt cat} and {\tt sort} are unusual filters.  {\tt
  cat} is unusual because it reads in text and performs \emph{no}
changes on it.  {\tt sort} is unusual because it reads in lines and
doesn't output anything until after it's seen the EOF character.  Many
filters run on a line-by-line basis: they will read in a line, perform
some computations, and output a different line.

\section{Helping Yourself}\label{man-section}\bindex{help!on-line}

The {\tt man}\impttindex{man} command displays reference pages for the
command\footnote{{\tt man} will also display information on a system
  call, a subroutine, a file format, and more.  In the original
  version of \unix\ it showed the exact same information the printed
  documentation would.  For now, you're probably only interested in
  getting help on commands.} you specify. For example:

\begin{screen}
\begin{verbatim}
/home/larry# man cat

cat(1)                                                     cat(1)

NAME
  cat - Concatenates or displays files

SYNOPSIS
  cat [-benstuvAET] [--number] [--number-nonblank] [--squeeze-blank]
  [--show-nonprinting] [--show-ends] [--show-tabs] [--show-all]
  [--help] [--version] [file...]

DESCRIPTION
  This manual page documents the GNU version of cat ...
\end{verbatim}
\end{screen}

There's about one full page of information about {\tt cat}. Try
running {\tt man} now.  Don't expect to understand the manpage given.
Manpages usually assume quite a bit of \unix\ knowledge---knowledge
that you might not have yet.  When you've read the page, there's
probably a little black block at the bottom of your screen similar to
``{\tt --more--}'' or ``{\tt Line 1}''.  This is the
\concept{more-prompt}, and you'll learn to love it.

Instead of just letting the text scroll away, {\tt man} stops at the
end of each page, waiting for you to decide what to do now. If you
just want to go on, press \key{Space}\ and you'll advance a page. If
you want to exit (quit) the manual page you are reading, just press
\key{q}. You'll be back at the shell prompt, and it'll be waiting for
you to enter a new command.

There's also a keyword function in {\tt man}. For example, say you're
interested in any commands that deal with Postscript, the printer
control language from Adobe. Type {\tt man -k ps} or {\tt man -k
  Postscript}, you'll get a listing of all commands, system calls, and
other documented parts of \unix\ that have the word ``ps'' (or
``Postscript'') in their name or short description. This can be very
useful when you're looking for a tool to do something, but you don't
know it's name---or if it even exists!

\eindex{help!on-line}

\section{Storing Information}

Filters are very useful once you are an experienced user, but they
have one small problem.  How do you store the information?  Surely you
aren't expected to type everything in each time you are going to use
the program! Of course not. \unix\ provides {\bf files} and {\bf
  directories}.\glossary{directory}

A directory is like a folder: it contains pieces of paper, or files.
A large folder can even hold other folders---directories can be inside
directories.  In \unix, the collection of directories and files is
called the file system.\index{file system} Initially, the file system
consists of one directory, called the ``root''
directory.\index{directory!root} Inside this directory, there are more
directories, and inside those directories are files and yet more
directories.\footnote{There may or may not be a limit to how ``deep''
  the file system can go.  (I've never reached it---one can easily
  have directories 10 levels deep.)}

Each file and each directory has a name.  It has both a short name, which
can be the same as another file or directory somewhere else on the system,
and a long name which is unique.  A short name for a file could be {\tt
joe}, while it's ``full name'' would be {\tt /home/larry/joe}. The full
name is usually called the {\bf path}\glossary{path}.  The path can be
decode into a sequence of directories.  For example, here is how {\tt
/home/larry/joe} is read:
\begin{tabbing}
\tt /\=\tt home/\=\tt larry/\=\tt joe\\
The initial slash indicates the root directory.\+\\
This signifies the directory called {\tt home}. It is inside the
root directory.\+\\
This is the directory {\tt larry}, which is inside {\tt home}.\+\\
{\tt joe} is inside {\tt larry}.  A path could refer to either a
directory or a filename,\\ so {\tt joe} could be either.  All the items
{\em before\/} the short name must be directories.
\end{tabbing}

An easy way of visualizing this is a tree diagram.  To see a diagram
of a typical \linux\ system, look at Figure~\ref{standard-dirtree}.
Please note that this diagram isn't complete---a full \linux\ system
has over 8000 files!---and shows only some of the standard
directories.  Thus, there may be some directories in that diagram that
aren't on your system, and your system almost certainly has
directories not listed there.

\unitlength=1.0pt
\begin{figure}[bt]
\caption{A typical (abridged) Unix directory tree.}
\label{standard-dirtree}
\begin{picture}(148.00,365.00)(0.00,450.00)
\put(9.00,805.00){\line(1,0){29.00}} % / -> bin
\put(26.00,805.00){\line(0,-1){112.00}} % /'s children
\put(26.00,791.00){\line(1,0){12.00}} % dev
\put(26.00,777.00){\line(1,0){12.00}} % etc
\put(26.00,763.00){\line(1,0){12.00}} % home
\put(64.50,763.00){\line(1,0){29.00}} % home -> larry
\put(81.50,763.00){\line(0,-1){14.00}} % home's children
\put(81.50,749.00){\line(1,0){12.00}} % sam
\put(26.00,735.00){\line(1,0){12.00}} % lib
\put(26.00,721.00){\line(1,0){12.00}} % proc
\put(26.00,707.00){\line(1,0){12.00}} % tmp
\put(26.00,693.00){\line(1,0){12.00}} % usr
\put(55.50,693.00){\line(1,0){29.00}} % usr -> X386
\put(72.50,693.00){\line(0,-1){238.00}} % usr's children
\put(72.50,676.00){\line(1,0){12.00}} % bin
\put(72.50,659.00){\line(1,0){12.00}} % emacs
\put(72.50,642.00){\line(1,0){12.00}} % etc
\put(72.50,625.00){\line(1,0){12.00}} % g++-include
\put(72.50,608.00){\line(1,0){12.00}} % include
\put(72.50,591.00){\line(1,0){12.00}} % lib
\put(72.50,574.00){\line(1,0){12.00}} % local
\put(107.00,574.00){\line(1,0){29.00}} % local -> bin
\put(124.00,574.00){\line(0,-1){51.00}} % local's children
\put(124.00,557.00){\line(1,0){12.00}} % emacs
\put(124.00,540.00){\line(1,0){12.00}} % etc
\put(124.00,523.00){\line(1,0){12.00}} % lib
\put(72.50,506.00){\line(1,0){12.00}} % man
\put(72.50,489.00){\line(1,0){12.00}} % spool
\put(72.50,472.00){\line(1,0){12.00}} % src
\put(100.50,472.00){\line(1,0){29.00}} % src -> linux
\put(72.50,455.00){\line(1,0){12.00}} % tmp
\put(8.50,805.00){\makebox(0,0)[rc]{/}}
\put(39.50,805.00){\makebox(0,0)[lc]{bin}}
\put(39.50,791.00){\makebox(0,0)[lc]{dev}}
\put(39.50,777.00){\makebox(0,0)[lc]{etc}}
\put(39.50,763.00){\makebox(0,0)[lc]{home}}
\put(95.00,763.00){\makebox(0,0)[lc]{larry}}
\put(95.00,749.00){\makebox(0,0)[lc]{sam}}
\put(39.50,735.00){\makebox(0,0)[lc]{lib}}
\put(39.50,721.00){\makebox(0,0)[lc]{proc}}
\put(39.50,707.00){\makebox(0,0)[lc]{tmp}}
\put(39.50,693.00){\makebox(0,0)[lc]{usr}}      % I'm expecting you to
\put(86.00,693.00){\makebox(0,0)[lc]{X11R6}}    % proof-read this!
\put(86.00,676.00){\makebox(0,0)[lc]{bin}}      
\put(86.00,659.00){\makebox(0,0)[lc]{emacs}}    % I am, I am, don't worry! :-)
\put(86.00,642.00){\makebox(0,0)[lc]{etc}}
\put(86.00,625.00){\makebox(0,0)[lc]{g++-include}}
\put(86.00,608.00){\makebox(0,0)[lc]{include}}
\put(86.00,591.00){\makebox(0,0)[lc]{lib}}
\put(86.00,574.00){\makebox(0,0)[lc]{local}}
\put(137.50,574.00){\makebox(0,0)[lc]{bin}}
\put(137.50,557.00){\makebox(0,0)[lc]{emacs}}
\put(137.50,540.00){\makebox(0,0)[lc]{etc}}
\put(137.50,523.00){\makebox(0,0)[lc]{lib}}
\put(86.00,506.00){\makebox(0,0)[lc]{man}}
\put(86.00,489.00){\makebox(0,0)[lc]{spool}}
\put(86.00,472.00){\makebox(0,0)[lc]{src}}
\put(130.50,472.00){\makebox(0,0)[lc]{linux}}
\put(86.00,455.00){\makebox(0,0)[lc]{tmp}}
\end{picture}
\end{figure}

\subsection{Looking at Directories with {\tt ls}}

Now that you know that files and directories exist, there must be some
way of manipulating them.  Indeed there is.  The command {\tt
  ls}\ttindex{ls} is one of the more important ones. It {\bf l}i{\bf
  s}ts files.  If you try {\tt ls} as a command, you'll see:

\begin{screen}\begin{verbatim}
/home/larry# ls
/home/larry#
\end{verbatim}\end{screen}

That's right, you'll see nothing. \unix\ is intensionally terse: it
gives you nothing, not even ``no files'' if there aren't any files.
Thus, the lack of output was {\tt ls}'s way of saying it didn't find
any files.

But I just said there could be 8000 or more files lying around: where
are they? You've run into the concept of a ``current'' directory. You
can see in your prompt that your current directory is {\tt
  /home/larry}, where you don't have any files.  If you want a list of
files of a more active directory, try the root directory:

\begin{screen}\begin{verbatim}
/home/larry# ls /
bin      etc      install  mnt      root     user     var
dev      home     lib      proc     tmp      usr      vmlinux
/home/larry# 
\end{verbatim}
\end{screen}

In the above command, ``{\tt ls /}'', the directory (``{\tt /}'') is a
\concept{parameter}. The first word of the command is the command
name, and anything after it is a parameter.  Parameters generally
modify what the program is acting on---for {\tt ls}, the parameters
say what directory you want a list for.  Some commands have special
parameters called options or switches. To see this try:

\begin{screen}\begin{verbatim}
/home/larry# ls -F /
bin/      etc/      install/  mnt/      root/     user/     var@
dev/      home/     lib/      proc/     tmp/      usr/      vmlinux
/home/larry# 
\end{verbatim}
\end{screen}

The {\tt -F} is an \concept{option}.  An option is a special kind of
parameter that starts with a dash and modifies how the program runs,
but not what the program runs on.  For {\tt ls}, {\tt -F} is an option
that lets you see which ones are directories, which ones are special
files, which are programs, and which are normal files.  Anything with
a slash is a directory. We'll talk more about {\tt ls}'s features
later. It's a surprisingly complex program!

Now, there are two lessons to be learned here. First, you should learn
what {\tt ls} does. Try a few other directories that are shown in
Figure~\ref{standard-dirtree}, and see what they contain. Naturally,
some will be empty, and some will have many, many files in them.  I
suggest you try {\tt ls} both with and without the {\tt -F} option.
For example, {\tt ls /usr/local} looks like:

\begin{screen}\begin{verbatim}
/home/larry# ls /usr/local
archives  bin       emacs     etc       ka9q      lib       tcl
/home/larry# 
\end{verbatim}
\end{screen}

The second lesson is more general. Many \unix\ commands are like {\tt
  ls}. They have options, which are generally one character after a
dash, and they have parameters.  Unlike {\tt ls}, some commands
\emph{require} certain parameters and/or options.  To show what
commands generally look like, we'll use the following form:

\begin{command}
{\tt ls} [-aRF] [{\sl directory}]
\end{command}

I'll generally use command templates like that before I introduce any
command from now on.  The first word is the command (in this case {\tt
  ls}).  Following the command are all the parameters.  Optional
parameters are contained in brackets (``['' and ``]'').
Meta-variables are {\sl slanted\/}---they're words that take the place
of actual parameters.  (For example, above you see {\sl directory},
which should be replaced by the name of a real directory.)

Options are a special case.  They're enclosed by brackets, but you can
take any one of them without using all of them.  For instance, with
just the three options given for {\tt ls} you have eight different
ways of running the command: with or without each of the options.
(Contrast {\tt ls -R} with {\tt ls -F}.)

\subsection{The Current Directory and {\tt cd}}

\begin{command}
{\tt pwd}
\end{command}

Using directories would be cumbersome if you had to type the full path
each time you wanted to access a directory.  Instead, \unix\ shells
have a feature called the ``current'' or ``present'' or ``working''
directory.  Your setup most likely displays your directory in your
prompt: {\tt /home/larry}. If it doesn't, try the command {\tt pwd},
for {\bf p}resent {\bf w}orking {\bf d}irectory.  (Sometimes the
prompt will display the machine name.  This is only really useful in a
networked environment with lots of different machines.)
\ttindex{pwd}
\index{directory!current}
\index{directory!present}
\index{directory!working}

\begin{screen}\begin{verbatim}
mousehouse>pwd
/home/larry
mousehouse>  
\end{verbatim}
\end{screen}

\begin{command}
{\tt cd} [{\sl directory}]
\end{command}

As you can see, {\tt pwd} tells you your current
directory\footnote{You'll see all the terms in this book: present
  working directory, current directory, or working directory.  I
  prefer ``current directory'', although at times the other forms will
  be used for stylistic purposes.}---a very simple command.  Most
commands act, by default, on the current directory.  For instance,
{\tt ls} without any parameters displays the contents of the current
directory.  We can change our current directory using {\tt
  cd}\ttindex{cd}. For instance, try:

\begin{screen}\begin{verbatim}
/home/larry# cd /home
/home# ls -F
larry/     sam/       shutdown/  steve/     user1/
/home# 
\end{verbatim}
\end{screen}

If you omit the optional parameter {\sl directory}, you're returned to
your home, or original, directory.  Otherwise, {\tt cd} will change
you to the specified directory. For instance:

\begin{screen}\begin{verbatim}
/home# cd
/home/larry# cd /
/# cd home
/home# cd /usr
/usr# cd local/bin
/usr/local/bin#
\end{verbatim}
\end{screen}

As you can see, {\tt cd} allows you to give either absolute or
relative pathnames.  An \concept{absolute path} starts with {\tt /}
and specifies all the directories before the one you wanted.  A
\concept{relative path} is in relation to your current directory.  In
the above example, when I was in {\tt /usr}, I made a relative move to
{\tt local/bin}---{\tt local} is a directory under {\tt usr}, and {\tt
  bin} is a directory under {\tt local}!  ({\tt cd home} was also a
relative directory change.)

There are two directories used {\em only\/} for relative pathnames:
``{\tt .}'' and ``{\tt ..}''.\index{directory!current}
\index{directory!parent}.  The directory ``{\tt .}'' refers
to the current directory and ``{\tt ..}'' is the parent directory.
These are ``shortcut'' directories.  They exist in {\em every\/}
directory, but don't really fit the ``folder in a folder'' concept.
Even the root directory has a parent directory---it's its own parent!

The file {\tt ./chapter-1} would be the file called {\tt chapter-1}
in the current directory.  Occasionally, you need to put the ``{\tt
  ./}'' for some commands to work, although this is rare.  In most
cases, {\tt ./chapter-1} and {\tt chapter-1} will be identical.

The directory ``{\tt ..}'' is most useful in ``backing up'':

\begin{screen}\begin{verbatim}
/usr/local/bin# cd ..
/usr/local# ls -F
archives/  bin/       emacs@     etc/       ka9q/      lib/       tcl@
/usr/local# ls -F ../src
cweb/      linux/     xmris/
/usr/local#
\end{verbatim}\end{screen}

In this example, I changed to the parent directory using {\tt cd ..},
and I listed the directory {\tt /usr/src} from {\tt /usr/local} using
{\tt ../src}. Note that if I was in {\tt /home/larry}, typing {\tt ls
  -F ../src} wouldn't do me any good!

The directory {\tt \verb+~+/} is an alias for your home
directory\index{directory!home}:

\begin{screen}\begin{verbatim}
/usr/local# ls -F ~/
/usr/local# 
\end{verbatim}\end{screen}

You can see at a glance that there isn't anything in your home
directory!  {\tt \verb+~+/} will become more useful as we learn more
about how to manipulate files.

\subsection{Creating and Removing Directories}

\index{mkdir@{\tt mkdir}|(}\bindex{directory!creating} 

\begin{command}
{\tt mkdir} {\sl directory1} [{\sl directory2 \ldots directoryN}]
\end{command}

Creating your own directories is extremely simple under \unix, and can
be a useful organizational tool. To create a new directory, use the
command {\tt mkdir}.  Of course, {\tt mkdir} stands for {\bf m}a{\bf
  k}e {\bf dir}ectory.

Let's do a small example to see how this works:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
/home/larry# mkdir report-1993
/home/larry# ls -F
report-1993/
/home/larry# cd report-1993
/home/larry/report-1993#
\end{verbatim}
\end{screen}

{\tt mkdir} can take more than one parameter, interpreting each
parameter as another directory to create.  You can specify either the
full pathname or a relative pathname; {\tt report-1993} in the above
example is a relative pathname.

\begin{screen}\begin{verbatim}
/home/larry/report-1993# mkdir /home/larry/report-1993/chap1 ~/report-1993/chap2
/home/larry/report-1993# ls -F
chap1/  chap2/
/home/larry/report-1993#
\end{verbatim}\end{screen}

\begin{command}
  {\tt rmdir} {\sl directory1} [{\sl directory2 \ldots directoryN}]
\end{command}

The opposite of {\tt mkdir} is {\tt rmdir} ({\bf r}e{\bf m}ove {\bf
  dir}ectory).  {\tt rmdir} works exactly like {\tt mkdir}.
\ttindex{rmdir}

An example of {\tt rmdir} is:

\begin{screen}\begin{verbatim}
/home/larry/report-1993# rmdir chap1 chap3
rmdir: chap3: No such file or directory
/home/larry/report-1993# ls -F
chap2/
/home/larry/report-1993# cd ..
/home/larry# rmdir report-1993
rmdir: report-1993: Directory not empty
/home/larry#
\end{verbatim}\end{screen}

As you can see, {\tt rmdir} will refuse to remove a non-existant
directory, as well as a directory that has anything in it. (Remember,
{\tt report-1993} has a subdirectory, {\tt chap2}, in it!) There is
one more interesting thing to think about {\tt rmdir}: what happens if
you try to remove your current directory? Let's find out:

\begin{screen}\begin{verbatim}
/home/larry# cd report-1993
/home/larry/report-1993# ls -F
chap2/
/home/larry/report-1993# rmdir chap2
/home/larry/report-1993# rmdir .
rmdir: .: Operation not permitted
/home/larry/report-1993#
\end{verbatim}\end{screen}

Another situation you might want to consider is what happens if you try
to remove the parent of your current directory. This turns out not to
be a problem since the parent of your current directory isn't empty, so
it can't be removed!
\index{mkdir@{\tt mkdir}|)}\eindex{directory!creating}

\section{Moving Information}

All of these fancy directories are very nice, but they really don't
help unless you have some place to store you data.  The \unix\ 
Gods\index{Gods!\unix} saw this problem, and they fixed it by giving
the users \concept{files}.



We will learn more about creating and editing files in the next few
chapters.

The primary commands for manipulating files under \unix\ are {\tt cp},
{\tt mv}, and {\tt rm}.  They stand for {\bf c}o{\bf p}y, {\bf m}o{\bf
  v}e, and {\bf r}e{\bf m}ove, respectively.

\subsection{{\tt cp} Like a Monk}\bttindex{cp}

\begin{command}
{\tt cp} [-i] {\sl source} {\sl destination}\\
{\tt cp} [-i] {\sl file1 file2 \ldots fileN} {\sl
  destination-directory}\footnote{{\tt cp} has two lines in its
  template because the meaning of the second parameter can be
  different depending on the number of parameters.}
\end{command}

{\tt cp} is a very useful utility under \unix, and extremely powerful.  It
enables one person to copy more information in a second than a fourteenth
century monk could do in a year.

\cautionpar Be careful with {\tt cp} if you don't have a lot of disk
space.  No one wants to see a ``Disk full'' message when working on
important files. {\tt cp} can also overwrite existing files without
warning---I'll talk more about that danger later.

We'll first talk about the first line in the command template.  The
first parameter to {\tt cp} is the file to copy---the second is where to
copy it.  You can copy to either a different filename, or a different
directory. Let's try some examples:

\begin{screen}\begin{verbatim}
/home/larry# ls -F /etc/passwd
/etc/passwd
/home/larry# cp /etc/passwd .
/home/larry# ls -F
passwd
/home/larry# cp passwd frog
/home/larry# ls -F
frog  passwd
/home/larry#
\end{verbatim}
\end{screen}

The first {\tt cp} command I ran took the file {\tt
  /etc/passwd}\ttindex{/etc/passwd}, which contains the names of all
the users on the \unix\ system and their (encrypted) passwords, and
copied it to my home directory.  {\tt cp} doesn't delete the source
file, so I didn't do anything that could harm the system.  So two
copies of {\tt /etc/passwd} exist on my system now, both named {\tt
  passwd}, but one is in the directory {\tt /etc} and one is in {\tt
  /home/larry}.

Then I created a {\em third\/} copy of {\tt
  /etc/passwd}\ttindex{/etc/passwd} when I typed {\tt cp passwd
  frog}---the three copies are now: {\tt /etc/passwd}, {\tt
  /home/larry/passwd} and {\tt /home/larry/frog}. The contents of
these three files are the same, even if the names aren't.

{\tt cp} can copy files between directories if the first parameter is a
file and the second parameter is a directory.  In this case, the short
name of the file stays the same.

It can copy a file and change it's name if both parameters are file
names. Here is one danger of {\tt cp}. If I typed {\tt cp /etc/passwd
/etc/group}, {\tt cp} would normally create a new file with the contents
identical to {\tt passwd} and name it {\tt group}.  However, if {\tt
/etc/group} already existed, {\tt cp} would destroy the old file without
giving you a chance to save it!  (It won't even print out a message
reminding you that you're destroying a file by copying over it.)

Let's look at another example of {\tt cp}:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
frog  passwd
/home/larry# mkdir passwd_version
/home/larry# cp frog passwd passwd_version
/home/larry# ls -F
frog         passwd        passwd_version/
/home/larry# ls -F passwd_version
frog  passwd
/home/larry#
\end{verbatim}
\end{screen}

How did I just use {\tt cp}? Evidentally, {\tt cp} can take {\em
  more\/} than two parameters.  (This is the second line in the
command template.)  What the above command did is copied all the files
listed ({\tt frog} and {\tt passwd}) and placed them in the {\tt
  passwd\_version} directory. In fact, {\tt cp} can take any number of
parameters, and interprets the first $n-1$ parameters to be files to
copy, and the $n^{\rm th}$ parameter as what directory to copy them
too.

\cautionpar You cannot rename files when you copy more than one at a
time---they always keep their short name. This leads to an interesting
question. What if I type {\tt cp frog passwd toad}, where {\tt frog} and {\tt
passwd} exist and {\tt toad} isn't a directory? Try it and see.

\ettindex{cp}

\subsection{Pruning Back with {\tt rm}}\bttindex{rm}

\begin{command}
{\tt rm} [-i] {\sl file1 file2 \ldots fileN}
\end{command}

Now that we've learned how to create millions of files with {\tt
cp}\ttindex{cp} (and believe me, you'll find new ways to create more files
soon), it may be useful to learn how to delete them. Actually, it's very
simple: the command you're looking for is {\tt rm}, and it works just like
you'd expect: any file that's a parameter to {\tt rm} gets deleted.

For example:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
frog         passwd        passwd_version/
/home/larry# rm frog toad passwd
rm: toad: No such file or directory
/home/larry# ls -F
passwd_version/
/home/larry#
\end{verbatim}\end{screen}

As you can see, {\tt rm} is extremely unfriendly.  Not only does it not ask
you for confirmation, but it will also delete things even if the whole
command line wasn't correct. This could actually be dangerous. Consider
the difference between these two commands:
\begin{screen}\begin{verbatim}
/home/larry# ls -F
toad  frog/
/home/larry# ls -F frog
toad
/home/larry# rm frog/toad
/home/larry#
\end{verbatim}\end{screen}
and this
\begin{screen}\begin{verbatim}
/home/larry# rm frog toad
rm: frog is a directory
/home/larry# ls -F
frog/
/home/larry#
\end{verbatim}\end{screen}

\cautionpar As you can see, the difference of {\em one\/} character made
a world of difference in the outcome of the command. It is vital that you
check your command lines before hitting \ret!

\ettindex{rm}

\subsection{A Forklift Can Be Very Handy}\bttindex{mv}

\begin{command}
{\tt mv} [-i] {\sl old-name} {\sl new-name}\\
{\tt mv} [-i] {\sl file1 file2 \ldots fileN} {\sl new-directory}
\end{command}

Finally, the other file command you should be aware of is {\tt mv}. {\tt
mv} looks a lot like {\tt cp}, except that it deletes the original file
after copying it.  It's a lot like using {\tt cp} and {\tt rm}
together. Let's take a look at what we can do:

\begin{screen}\begin{verbatim}
/home/larry# cp /etc/passwd .
/home/larry# ls -F
passwd
/home/larry# mv passwd frog
/home/larry# ls -F
frog
/home/larry# mkdir report
/home/larry# mv frog report
/home/larry# ls -F
report/
/home/larry# ls -F report
frog
/home/larry#
\end{verbatim}\end{screen}

As you can see, {\tt mv} will rename a file if the second parameter is a
file. If the second parameter is a directory, {\tt mv} will move the file
to the new directory, keeping it's shortname the same.

\cautionpar You should be very careful with {\tt mv}---it doesn't check 
to see if the file already exists, and will remove any old file in its way.
For instance, if I had a file named {\tt frog} already in my directory {\tt
report}, the command {\tt mv frog report} would delete the file {\tt
\verb+~+/report/frog} and replace it with {\tt \verb+~+/frog}.

In fact, there is one way to make {\tt rm}, {\tt cp} and {\tt mv} ask
you before deleting files.  All three of these commands accept the
{\tt -i} option, which makes them query the user before removing any
file. If you use an {\bf alias}, you can make the shell do {\tt rm -i}
automatically when you type {\tt rm}.  You'll learn more about this
later in Section~\ref{aliasing-section} on
page~\pageref{aliasing-section}.

\ettindex{mv}

% Local Variables: 
% mode: latex
% TeX-master: "guide"
% End: 
